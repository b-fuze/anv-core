"use strict";
// LCES Reimplemented/Lightly Revised in TypeScript
Object.defineProperty(exports, "__esModule", { value: true });
const jshorts_1 = require("jshorts");
class ComponentState {
    /**
     * Component State
     * @param name   Name of the state
     * @param config State config
     */
    constructor(name, defaultValue, config) {
        // Create callback arrays
        this.conditionCallbacks = [];
        this.callbacks = [];
        // Default config
        this.oldValue = undefined;
        this.value = defaultValue;
        this.writable = true;
        this.writableStrict = false;
        this.forceTrigger = false;
        // Set name
        this.name = name;
        // Add config
        if (config) {
            Object.assign(this, config);
        }
    }
    // Methods
    addCallback(callback, isConditional) {
        const callbacks = isConditional ? this.conditionCallbacks : this.callbacks;
        callbacks.push(callback);
    }
    removeCallback(callback, isConditional) {
        const callbacks = isConditional ? this.conditionCallbacks : this.callbacks;
        const index = callbacks.indexOf(callback);
        if (index !== -1) {
            return callbacks.splice(index, 1)[0];
        }
        else {
            return null;
        }
    }
    addConditionalCallback(callback) {
        this.addCallback(callback, true);
    }
    removeConditionalCallback(callback) {
        return this.removeCallback(callback, true);
    }
}
exports.ComponentState = ComponentState;
class ComponentEvent {
    constructor(name) {
        this.name = name;
        this.callbacks = [];
    }
    // Methods
    addCallback(callback) {
        this.callbacks.push(callback);
    }
    removeCallback(callback) {
        const index = this.callbacks.indexOf(callback);
        if (index !== -1) {
            return this.callbacks.splice(index, 1)[0];
        }
        else {
            return null;
        }
    }
}
exports.ComponentEvent = ComponentEvent;
class Component {
    constructor() {
        this.states = {};
        this.events = {};
        this.timeouts = {
            timers: {},
            names: {},
        };
    }
    // Events
    newEvent(event) {
        this.eventExists(event, null, () => {
            const eventName = event.trim();
            if (eventName) {
                const eventObj = new ComponentEvent(event);
                this.events[eventName] = eventObj;
            }
            else {
                throw new Error(`LCES: "${eventName}" isn't a valid event name`);
            }
        });
    }
    on(event, callback) {
        this.eventExists(event, eventObj => {
            eventObj.addCallback(callback);
        });
    }
    triggerEvent(event, data) {
        this.eventExists(event, eventObj => {
            for (const callback of eventObj.callbacks) {
                callback(data);
            }
        });
    }
    removeEventListener(event, callback) {
        return this.eventExists(event, eventObj => {
            return eventObj.removeCallback(callback);
        });
    }
    // States
    newState(state, defaultValue, config) {
        this.stateExists(state, () => {
            // FIXME: Do nothing... For now...
        }, () => {
            const stateObj = new ComponentState(state, defaultValue, config);
            this.states[state] = stateObj;
        });
    }
    onState(state, callback) {
        this.stateExists(state, stateObj => {
            stateObj.addCallback(callback);
        });
    }
    stateCondition(state, callback) {
        this.stateExists(state, stateObj => {
            stateObj.addConditionalCallback(callback);
        });
    }
    removeStateListener(state, callback) {
        return this.stateExists(state, stateObj => {
            return stateObj.removeCallback(callback);
        });
    }
    removeConditionListener(state, callback) {
        return this.stateExists(state, stateObj => {
            return stateObj.removeConditionalCallback(callback);
        });
    }
    // State getters/setters
    getState(state) {
        return this.stateExists(state, stateObj => {
            return stateObj.value;
        });
    }
    setState(state, value, forceRecur = false) {
        return this.stateExists(state, stateObj => {
            let newValue = value;
            function alter(value) {
                newValue = value;
            }
            // Check state conditions
            for (const callback of stateObj.conditionCallbacks) {
                const result = callback.call(stateObj, newValue, alter);
                if (result) {
                    // Cancel
                    return;
                }
            }
            if (forceRecur || stateObj.forceTrigger || stateObj.value !== newValue) {
                stateObj.oldValue = stateObj.value;
                stateObj.value = newValue;
                // Trigger events
                for (const callback of stateObj.callbacks) {
                    callback.call(stateObj, newValue);
                }
            }
            return value;
        });
    }
    // Existence methods
    hasState(state) {
        return this.stateExists(state, () => true, () => false);
    }
    // Private meta methods
    eventExists(event, callback, voidCallback) {
        const eventObj = this.events[event];
        if (eventObj) {
            if (callback) {
                return callback(eventObj);
            }
        }
        else {
            if (voidCallback) {
                return voidCallback();
            }
            else {
                throw new ReferenceError(`LCES: Event "${event}" doesn't exist`);
            }
        }
    }
    stateExists(state, callback, voidCallback) {
        const stateObj = this.states[state];
        if (stateObj) {
            if (callback) {
                return callback(stateObj);
            }
        }
        else {
            if (voidCallback) {
                return voidCallback();
            }
            else {
                throw new ReferenceError(`LCES: State "${state}" doesn't exist`);
            }
        }
    }
    // Timeouts
    timeout(name, delay = 0, concat = false, reqAnimFrame = false) {
        if (!name) {
            throw new TypeError("Component.addTimeout: name must be a valid non-empty string");
        }
        // Update name timer delay list (if any)
        const nameList = this.timeouts.names[name] || (this.timeouts.names[name] = []);
        if (nameList.indexOf(delay) === -1) {
            nameList.push(delay);
        }
        // Get timer obj (if any) or create a new one
        const nameRef = name + (delay || 0);
        const timeoutObj = this.timeouts.timers[nameRef] || (this.timeouts.timers[nameRef] = {
            timeout: null,
            animFrame: {
                canceled: false,
                enabled: false,
            },
            callbacks: [],
        });
        // Create promise
        let promiseResolve = null;
        const promise = new Promise((res, rej) => {
            promiseResolve = res;
        });
        const callback = () => {
            promiseResolve();
        };
        // Clear any running timers if we aren't concatenating ours
        if (!concat && timeoutObj.timeout) {
            if (timeoutObj.animFrame.enabled) {
                timeoutObj.animFrame.canceled = true;
            }
            else {
                clearTimeout(timeoutObj.timeout);
            }
            timeoutObj.timeout = null;
            timeoutObj.animFrame = {
                canceled: false,
                enabled: false,
            };
            timeoutObj.callbacks = [];
        }
        // Add setTimeout timer if none are available
        if (timeoutObj.timeout === null) {
            if (reqAnimFrame) {
                timeoutObj.timeout = null;
                timeoutObj.animFrame = {
                    canceled: false,
                    enabled: true,
                };
                requestAnimationFrame(() => {
                    if (!timeoutObj.animFrame.canceled) {
                        for (const callback of timeoutObj.callbacks) {
                            callback.callback();
                        }
                    }
                });
            }
            else {
                timeoutObj.timeout = setTimeout(() => {
                    for (const callback of timeoutObj.callbacks) {
                        callback.callback();
                    }
                }, delay || 0);
            }
        }
        // Finally concatenate our callback
        timeoutObj.callbacks.push({
            callback
        });
        return promise;
    }
    clearTimeout(name, delay) {
        if (!(name in this.timeouts.names)) {
            return;
        }
        const timeoutObjs = []; // this.timeouts.timers[name];
        if (typeof delay === "number") {
            // Remove one specific timeout
            const timeoutObj = this.timeouts.timers[name + delay];
            if (timeoutObj) {
                timeoutObjs.push(timeoutObj);
            }
        }
        else {
            // Remove all timeouts with the same name regardless of delay
            for (const timeoutDelays of this.timeouts.names[name]) {
                timeoutObjs.push(this.timeouts.timers[name + timeoutDelays]);
            }
        }
        // Clear timers
        for (const timeoutObj of timeoutObjs) {
            if (timeoutObj.animFrame.enabled) {
                timeoutObj.animFrame.canceled = true;
            }
            else {
                clearTimeout(timeoutObj.timeout);
            }
            timeoutObj.timeout = null;
            timeoutObj.callbacks = [];
        }
    }
}
exports.Component = Component;
function request(reqParam) {
    const xhr = new XMLHttpRequest();
    const method = reqParam.method || "GET";
    // Create a RequestPromise
    let promise = null;
    let promiseResolve = null;
    let promiseReject = null;
    promise = (new Promise((res, rej) => {
        promiseResolve = res;
        promiseReject = rej;
    }));
    let success = function (data) {
        promiseResolve(data);
    };
    let fail = function () {
        promiseReject(xhr);
    };
    // Add xhr to promise
    promise.xhr = xhr;
    // Setup
    if (reqParam.setup) {
        reqParam.setup(xhr);
    }
    // Querystring
    let queryData = "";
    if (reqParam.query) {
        function recursion(obj) {
            if (jshorts_1.jSh.type(obj) === "array") {
                return encodeURIComponent(obj.join(","));
            }
            if (jshorts_1.jSh.type(obj) !== "object") {
                return encodeURIComponent(obj.toString());
            }
            var qs = "";
            for (const prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    const objValue = obj[prop];
                    switch (jshorts_1.jSh.type(objValue)) {
                        case "string":
                            qs += "&" + prop + "=" + encodeURIComponent(objValue);
                            break;
                        case "number":
                            qs += "&" + prop + "=" + objValue;
                            break;
                        case "array":
                            qs += "&" + prop + "=" + encodeURIComponent(objValue.join(";"));
                            break;
                        case "object":
                            qs += "";
                            break;
                        case "null":
                            qs += "&" + prop + "=null";
                            break;
                        case "undefined":
                            qs += "";
                            break;
                        default:
                            qs += "";
                    }
                }
            }
            return qs;
        }
        queryData = recursion(reqParam.query).substr(1);
    }
    else {
        queryData = "formData" in reqParam ? reqParam.formData : "";
        // Stringify data if it's not FormData
        if (queryData !== "" && !(queryData instanceof FormData)) {
            queryData = JSON.stringify(queryData);
        }
    }
    // Open url
    let url = reqParam.url;
    if (method === "GET" && queryData) {
        url += "?" + queryData;
    }
    xhr.open(method, reqParam.url, reqParam.async !== undefined ? reqParam.async : true);
    // Invoke callbacks
    xhr.onreadystatechange = function () {
        if (typeof reqParam.statechange === "function") {
            reqParam.statechange.call(this);
        }
        if (this.readyState === 4) {
            if (this.status === 200) {
                success(reqParam.json ? jshorts_1.jSh.parseJSON(this.responseText) : this.responseText);
            }
            else {
                if (fail) {
                    fail(xhr);
                }
            }
        }
    };
    // Add form header
    if (reqParam.form) {
        xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    // Send
    const oldCookies = document.cookie.split(/\s*;\s*/).map(c => [
        c.split("=")[0],
        c.split("=")[1]
    ]);
    // Strip off cookies
    if (reqParam.cookies === false) {
        const time = new Date();
        time.setTime(0);
        oldCookies.forEach(cookie => document.cookie = cookie[0] + "=; expires=" + time + "; path=/");
    }
    xhr.send(method === "POST" ? queryData : undefined);
    // Return cookies
    if (reqParam.cookies === false) {
        setTimeout(() => {
            oldCookies.forEach(cookie => {
                document.cookie = cookie[0] + "=" + cookie[1] + "; expires=; path=/";
            });
        }, 50);
    }
    return promise;
}
exports.request = request;
