let anvInstance: any = null;
export function setInstance(instance: any) {
  if (!anvInstance) {
    anvInstance = instance;
  }
}

interface BaseFacet {
  lastUse?: number;
  facetId?: string;
};

// FIXME: Use better naming
export interface ProviderItem {
  title: string;
  cover?: string;
  sources: MediaSourceItem[];
}

export interface MediaSourceItem {
  type: "stream" | "mirror" | "mediasource" | "media";
  number?: string;
  title?: "string";
  resolver?: string;
  url: string;
  tiers?: string[];
  fileExtension: string;
  sources?: MediaSourceSubItem[];
}

export interface MediaSourceSubItem {
  type: "stream" | "mirror" | "mediasource";
  url: string;
  tiers?: string[];
  resolver?: string;
}

export interface ProviderFacet extends BaseFacet {
  name: string;
  displayName?: string;
  description?: string;
  weight?: number;
  cacheSource?: boolean;
  delay?: number | ((ctx: {}, done: () => void) => void);
  resolvers: {
    mediaList?: string;
    mediaSource?: string;
  };
  hosts: (RegExp | string)[];
  validUrl(url: string, list: boolean): boolean;
  tiers?: [string, string][];
  mediaList(metaMediaList: any): ProviderItem | Promise<ProviderItem>;
  mediaSource?(metaMediaSource: any, direct: boolean): MediaSourceItem[];
  search?(query: string): string[];
  id?(url: string): string;
}

export interface MirrorResult {
  type?: "mirror" | "stream";
  url: string;
  options?: {
    [option: string]: any;
  }
}

export interface MirrorFacet extends BaseFacet {
  name: string;
  displayName?: string;
  description?: string;
  weight?: number;
  cache?: boolean;
  delay?: number | ((ctx: {}, done: () => void) => void);
  streamDelay?: number | ((ctx: {}, done: () => void) => void);
  maxConnections?: number;
  backtrack?: (data?: any) => boolean;
  resolver: string;
  streamResolver: string;
  forceReresolveParent?: boolean;
  reresolveDelay?: number;
  resolverOptions?: {
    [options: string]: any;
  };
  hosts: (RegExp | string)[];
  validUrl(url: string): boolean;
  tiers?: string[];
  media(metaMediaPage: string, tier: string, url: string): string | MirrorResult | Promise<MirrorResult>;

  // tmp things
  connectionCount?: number;
  lastStreamUse?: number;
}

export interface GenericResolverFacet extends BaseFacet {
  name: string;
  description?: string;
  weight?: number;
  resolve(url: string, done: (err: string, resource?: any) => void, options?: {
    [option: string]: any;
  }): void;
}

interface StreamResolverFacetResolve {
  stop(): void;
}

export interface StreamResolverFacet extends BaseFacet {
  name: string;
  description?: string;
  weight?: number;
  external?: boolean;
  streamData?: StreamData;
  resolve(url: string, bytes: number, out: (NodeJS.WritableStream & StreamOut), info?: (data: {size?: number; bytes?: number; speed?: number; finished?: boolean}) => void, options?: StreamOptions): StreamResolverFacetResolve
  resolve(url: string, bytes: number, out: string, info?: (data: {size?: number; bytes?: number; speed?: number; finished?: boolean}) => void, options?: StreamOptions): StreamResolverFacetResolve;
}

type StreamData = {[k: string]: any};

interface StreamOut {
  setSize(size: number): void;
  setStreamData(data: StreamData): void;
  getStreamData(): StreamData;
  getAccumBytes(): number;
  error(err: any): void;
  backtrack(): void;
  shouldBacktrack(data?: any): boolean;
}

export interface StreamOptions {
  [option: string]: any;
}

export type RegisterFuncFacets = "provider" | "mirror" | "genericresolver" | "streamresolver";

// FIXME: Refine these types
export interface RegisterFacetTypeMap {
  provider: ProviderFacet;
  mirror: MirrorFacet;
  genericresolver: GenericResolverFacet;
  streamresolver: StreamResolverFacet;
}

export function register<facet extends keyof RegisterFacetTypeMap>(facet: facet, facetOptions: RegisterFacetTypeMap[facet]): void {
  anvInstance.register(facet, facetOptions);
}

export function genericResolver(name: string, url: string, done: (err: any, data: any) => void, options: any = {}) {
  anvInstance.genericResolver(name, url, done, options);
}
