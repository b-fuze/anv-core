// jShorts
// declare const jSh: JShorts;

// Define main func
export declare const jSh: JShorts;
export type JshDiv = HTMLDivElement & JshExtendedNode<HTMLDivElement>;

interface JshExtendedNodeRelationMethod<T = Node> {
  (): T
}

interface JshExtendedNodeJshMethod<T = Node> {
  jSh<T>(selector: string): T[];
  jSh<T>(childIndex: number): T;
}

interface JshExtendedNodeSetCssMethod<T = Node> {
  (css: {[propName: string]: string | number}): T
}

export interface JshExtendedNode<T> {
  getParent<T2 = T>(): T2;
  jSh<T2 = T>(selector: string): (T2 & JshExtendedNode<T2>)[];
  jSh<T2 = T>(childIndex: number): T2 & JshExtendedNode<T2>;
  setCSS: JshExtendedNodeSetCssMethod<T>;
  on: T & HTMLElement["addEventListener"];
  appendChild<T2 = T>(...newchild: T2[]): T2
}

interface JShorts<T = Node> {
  <T2 = T>(selector: string, first: true): T2;
  <T2 = T>(selector: string): T2[];
  <T2 = T>(node: T2): T2 & JshExtendedNode<T2>;

  type: (obj: any) => "function" | "object" | "array" | "string" | "number" | "undefined" | "null";

  toArr: <TA = any>(obj: TA[]) => TA[];

  extendObj: (obj: any, extension: any, exclude: any[]) => GenericObject;

  constProp: (obj: GenericObject, propName: string, propValue: any) => void;

  inherit: (child: () => any, parent: () => any) => void;

  nChars: (string: string, count?: number) => string;

  strCapitalize: (string: string) => string;


  parseJSON: (json: string) => any;

  // FIXME: Finish numOp and strOp
  boolOp<DefT = boolean>(operand: any, defaultValue?: DefT): DefT | boolean;
  numOp<DefT = number>(operand: any, defaultValue?: DefT): DefT | number;
  strOp<DefT = string>(operand: any, defaultValue?: DefT): DefT | string;

  // DOM functions
  docFrag: () => DocumentFragment;

  d<T2 = T, E = Event>(args: JshDObjArg<T2, E>): JshDiv;
  d<T2 = T, E = Event>(className?: string, text?: string, child?: T2 | T2[], attributes?: AttributeObject, properties?: GenericObject, events?: EventsObject): JshDiv;

  c<T2 = T, E = Event>(elmName: string, args: JshDObjArg<T2, E>): T2;
  c<T2 = T, E = Event>(elmName: string, className?: string, text?: string, child?: T2 | T2[], attributes?: AttributeObject, properties?: GenericObject, events?: EventsObject): T2;

  e<T2 = T>(tag: string): T2;

  t: (text: string) => Text;

  svg: JshSvg;

  path: (className: string, points: string, style?: string) => SVGPathElement;
}

interface JshSvg {
  (className: string, width: number, height: number, children?: JshSvgChildren): SVGElement;

  rect: (className: string, props?: GenericObject, events?: EventsObject) => SVGRectElement;

  circle: (className: string, props?: GenericObject, events?: EventsObject) => SVGCircleElement;

  g: (className: string, children?: JshSvgChildren, props?: GenericObject, events?: EventsObject) => SVGGElement;

  text: (className: string, text: string, props?: GenericObject, events?: EventsObject) => SVGTextElement;

  tspan: (className: string, text: string, props?: GenericObject, events?: EventsObject) => SVGTSpanElement;

  polyline: (className: string, points: string, style?: string) => SVGPathElement;
}

// Type definitions
type GenericObject = {
  [propName: string]: any;
}

type AttributeObject = {
  [propName: string]: string;
}

type EventsObject = {
  [propName: string]: () => any;
}

type JshDObjArgProp<T = Node> = {
  [prop: string]: any;
}

export interface JshDObjArg<T = Node, E = Event> {
  sel?: string;
  text?: string;
  child?: T[] | T;
  attr?: {[propName: string]: string};
  prop?: JshDObjArgProp<T>;
  events?: {[propName: string]: (this: T, evt: E) => any};
}

type JshSvgChildren = SVGElement[] | null;
